---
title: C++标准程序库读书笔记1
date: 2018-03-27 22:02:06
categories:
- 技术 
tags:
- C++ STL
---

## 基础

### 模板
非类型模板参数 bitset
缺省模板参数
typename
模板成员函数（包括构造函数，但不能为virtual和缺省值）

### 基本类型显示初始化
int i = int()
基础类型会被初始化为0
<!--more-->

### 异常
void func() throw(); // 不抛出异常
void func() throw(bad_alloc); // 跑出bad_alloc异常
try catch
throw

### 命名空间
### bool 类型
### explicit 和 implicit
### 类型转换
dynamic_cast 属于执行期转换
### 常数静态成员
类中可以初始化
但是仍然需要在类外定义

### 头文件
标准C++头
标准C头
旧C头

### 错误和异常
语言支持的异常
例如: 
    new 失败
    dynamic_cast 失败
C++标准库发出的异常
    派生自logic_error
程序作用域外的异常
    runtime_error
    
图：
- exception 
  -- bad_alloc
  -- bad_cast
  -- bad_typeid
  -- logic_error
  ---- domain_error
  ---- invalid_argument
  ---- length_error
  ---- out_of_range
  -- ios_base::failure
  -- runtime_error
  ---- range_error
  ---- overflow_error
  ---- underflow_error
  -- bad_exception   

异常类别成员函数
what() 返回异常信息

派生新类别可以重写 what() 虚函数
配置器默认就好了

### pairs
直接构造
make_pair()函数构造

### auto_ptr
获取资源
执行操作
释放资源
比try catch 更加优雅

auto_ptr可以拿来当做另外一个auto_ptr的初值，普通指针不行

所有权转移
函数是数据终点
函数是数据起点

const auto_ptr<int> p(new int)
const 意味着不能更改auto_ptr的所有权，可以修改执行的内容
const auto_ptr 作为参数，新对象的任何赋值会导致编译错误

auto_ptr 作为成员，当对象删除时，auto_ptr会自动删除其所成员对象。为了避免意外转移所有权，可以将成员设置为const auto_ptr

易错点：
auto_ptr 不能共享所有权
不存在指向数组的auto_ptr（不是delete []）
不属于引用计数型智能指针
不满足STL容器对元素要求（拷贝和赋值后，原auto_ptr和新auto_ptr不等）

### 数值极限
climits 和 cfloat头文件
numeric_limits 类模板
有一些成员函数

### 辅助函数
min
max
swap

### 辅助性比较操作符号
using namespace std::rel_ops中定义了 != >= <= >
基于 == 和 <

### cstddef和cstdlib头文件
NULL 
size_t
ptrdiff_t
offsetof

atexit
exit
_exit
abort
EXIT_SUCCESS
EXIT_FAILURE

## STL 库







