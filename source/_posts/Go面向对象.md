---
title: Go 面向对象
date: 2018-03-26 21:24:42
categories:
- 技术 
tags:
- GO
---

# 面向对象
Go不具有继承、虚函数、构造函数、析构函数、隐藏this指针等传统面向对象编程特征。
## 类型系统
类型系统指一门语言的类型体系结构。典型的类型系统包括：
<!--more-->
* 基础类型
* 复合类型
* 可以指向任意对象的类型
* 值语义和引用语义
* 面向对象，即所有具备面向对象特征的类型
* 接口
类型系统描述了类型体系结构如何被关联
Go语言中大多数类型都是值语义，并且可以包含对应的操作方法。在需要的时候，可以给任何类型“增加”新方法。实现某个接口时，无需从该接口继承，只要实现该接口要求的所有方法即可。任何类型都可以被Any类型引用。Any类型是空接口，即interface{}

### 为类型添加方法
```
type Interger int

func (a *Interger)Add(b Interger){
    *a += b
}
```
注意需要修改变量的值时，传指针
“Go语言中没有隐藏this指针”
施加的目标显示传递，没有被隐藏
不需要非得是指针，也不用非得叫this

### 值和引用语义
基本类型和符合类型都是基于值语义
byte bool float32 string等
数组 结构体 指针等

a, b不同
```
var a = [3]int{1,2,3}
var b = a
b[1]++
```

想表达引用，需要用指针
a, b相同
```
var a = [3]int{1,2,3}
var b = &a
b[1]++
```

Q: 数组和对数组取地址区别？

4个看起来像引用类型，他们本质上与指针相关
* 数组切片
* map
* channel
* 接口

### 结构体
放弃了大量面向对象特征，保留了组合特征
跟C结构体非常像
``` 
type Rect struct{
    x, y float64
    width, height float64
}

func (r *Rect) Area() float64{
    return r.width * r.height
}

var r Rect
r.width = 10
r.height = 10
fmt.Println( r.Area() ) 
```

### 初始化
初始化方式
1、 new初始化
2、 空参数
3、 每一个参数均赋值
4、 部分赋值，但是要指定参数名称

```
rect1 := new(Rect)
rect1 := &Rect{}
rect1 := &Rect{0, 0, 100, 200}
rect1 := &Rect{witdh: 100}
```

未被初始化的变量被初始化
没有构造函数的概念
对象通过一个全局的创建函数New***完成

### 匿名组合

### 可见性
go语言可见性是基于包（文件）级别的
大写开头的符号在其他包中可见

### 接口
go语言编程哲学非常重要的机制

#### 非侵入式接口
一个类只要实现了接口要求的所有函数，那么这个类就实现了该接口

```
type File struct{
}
func (f *File) Read(buf [] byte) (n int, err error){

    return
}
type IFile interface{
    Read(buf [] byte) (n int, err error)
}

var file1 IFile = new(File)
var buf []byte
file1.Read(buf)
```

1. Go语言的标准库，再也不需要绘制库继承图，因为在Go中，继承并无意义
2. 实现类的时候，只需要关心自己应该提供哪些方法。不用纠结接口需要拆得多细才合理。
3. 不用为了实现一个接口而导入一个外部的包，因为多引用一个外部包，意味着更多的耦合。接口由使用方按照自身需求来定义，使用方无需关系是否有其他模块定义过类似的接口。

#### 接口赋值
两种情况：
1. 将对象实例赋值给接口
2. 将一个接口赋值给另外一个接口

注意函数推倒

如果两个接口定义的方法一样（顺序不重要），那么可以互相赋值，两个接口等价
注意接口和接口子集

#### 接口查询
在运行期才能够确定，不同于接口赋值
```
var file1 IFile
if file5, ok := file1.(pack.IStream); ok{

} 
```

file1 file5 都是接口
pack.IStream 指代一个接口
判断file1是否实现了pack.IStream接口
Go语言中，只要对象满足了某些技能要求，就认为它是某种对象，不同于C++的继承机制。

#### 类型查询
有点类似接口查询
更加直截了当地问接口指向的对象实例类型

#### 接口组合
看作类型组合的特例，只包含方法，不包含任何成员变量

#### Any类型
空接口Interface{}
当函数可以接受任意对象实例时，我们将其声明为interface{}






